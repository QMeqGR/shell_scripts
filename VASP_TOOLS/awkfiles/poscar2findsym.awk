BEGIN{

# awk program to convert POSCAR to findsym or symsearch files

# set these on the command line
#  rms=0.00001;
#  search_type=3;
#  findsym=0;
#  symsearch=0;
#  origin=1; (defalt setting for findsym is 2)

#
#  "axis b"    unique axis b for monoclinic space groups (default)
#  axisc=1;   "axis c"    unique axis c for monoclinic space groups
#  "cell 1"    cell choice 1 for centered monoclinic space groups (default)
#  mono2=1;   "cell 2"    cell choice 2 for centered monoclinic space groups
#  mono3=1;   "cell 3"    cell choice 3 for centered monoclinic space groups
#  "origin 1"  origin choice 1 (when point of inversion is not at origin)
#  "origin 2"  origin choice 2 (point of inversion at origin, default)
#  "axes h"    hexagonal axes for R-centered space groups (default)
#  axesr=1;   "axes r"    rhombohedral axes for R-centered space groups



  r1[3];
  r2[3];
  r3[3];
  p[3000];
  nat=0;
  count=0;


}
# note: this is coded to work with the output of
# icsd2poscar.awk, in which
# the first line should read: "Z: Z1 Z2 Z3 ..."
(NR==1){ for(i=2;i<NF+1;i++) { elem[i-1]=$i; ntyp=(i-1); } }

# if I change the first line of output back to
# Ca B H
# i.e., without the 'Z:' then this line works
# and looks cleaner and is easier to read
# (NR==1){ for(i=2;i<NF+1;i++) { elem[i]=$i; ntyp=i); } }

(NR==2){ scalefact=$1; }
(NR==3){ for(i=1;i<4;i++) { r1[i]=$i*scalefact; } }
(NR==4){ for(i=1;i<4;i++) { r2[i]=$i*scalefact; } }
(NR==5){ for(i=1;i<4;i++) { r3[i]=$i*scalefact; } }
(NR==6){ for(i=1;i<NF+1;i++) { numtyp[i]=$i; nat+=$i; } }
(NR>6 && NF>1) {
  p[3*count+0]=$1;
  p[3*count+1]=$2;
  p[3*count+2]=$3;
  count++;
}

END{
  if ( findsym ) {
    printf("Autogenerated from poscar2findsym.awk\n");
    printf("%f       displacement rms\n",rms);
    printf("1                 lattice input type\n");
    printf("%15.8f%15.8f%15.8f\n",r1[1],r1[2],r1[3]);
    printf("%15.8f%15.8f%15.8f\n",r2[1],r2[2],r2[3]);
    printf("%15.8f%15.8f%15.8f\n",r3[1],r3[2],r3[3]);
    printf("1               basis vector in type\n");
    printf("1 0 0\n");
    printf("0 1 0\n");
    printf("0 0 1\n");
  }
  if ( symsearch ) {
    printf("Title\n");
    printf("%d                 search type\n",search_type);
    printf("%f %f       displacement rms max min\n",5.0,rms);
    printf("%f %f       strain rms max min\n",0.1,rms);
    printf("1                 lattice input type\n");
    printf("%15.8f%15.8f%15.8f\n",r1[1],r1[2],r1[3]);
    printf("%15.8f%15.8f%15.8f\n",r2[1],r2[2],r2[3]);
    printf("%15.8f%15.8f%15.8f\n",r3[1],r3[2],r3[3]);
    printf("1 0 0\n");
    printf("0 1 0\n");
    printf("0 0 1\n");
  }


  printf("%d\n",nat);  
  for(j=1;j<ntyp+1;j++) {
    for(i=0;i<numtyp[j];i++){
      elm=elem[j];
      printf("%d ",elm);
    }
  }
  printf("\n");
  count=0;
  for(j=1;j<ntyp+1;j++) {
    elm=elem[j];
    for(i=0;i<numtyp[j];i++){
      at=count;
      printf("%15.8f%15.8f%15.8f\n",p[3*at+0],p[3*at+1],p[3*at+2]);
      count++;
    }
    printf("\n");
  }
  if ( axisc==1 )   printf("axis c\n");
  if ( mono==2 )    printf("cell 2\n");
  if ( mono==3 )    printf("cell 3\n");
  if ( origin== 1 ) printf("origin 1\n");
  if ( axesr==1 )   printf("axes r\n");
  printf("\n");
}
